<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.core.domain.user.repository.UserRepository">

    <!-- Result Map -->
    <resultMap id="userEntityResultMap" type="com.core.domain.user.entity.UserEntity">
        <id property="id" column="id"/>
        <result property="username" column="username"/>
        <result property="email" column="email"/>
        <result property="isActive" column="is_active"/>
        <result property="status" column="status"/>
        <result property="orderCount" column="order_count"/>
        <result property="createdAt" column="created_at"/>
        <result property="updatedAt" column="updated_at"/>
        <result property="deletedAt" column="deleted_at"/>
    </resultMap>

    <!-- 모든 사용자 조회 -->
    <select id="findAll" resultMap="userEntityResultMap">
        SELECT id, username, email, is_active, status, order_count, created_at, updated_at, deleted_at
        FROM users
        WHERE deleted_at IS NULL
        ORDER BY id DESC
    </select>

    <!-- ID로 사용자 조회 -->
    <select id="findById" parameterType="long" resultMap="userEntityResultMap">
        SELECT id, username, email, is_active, status, order_count, created_at, updated_at, deleted_at
        FROM users
        WHERE id = #{id}
    </select>

    <!-- 사용자명으로 사용자 조회 -->
    <select id="findByUsername" parameterType="string" resultMap="userEntityResultMap">
        SELECT id, username, email, is_active, status, order_count, created_at, updated_at, deleted_at
        FROM users
        WHERE username = #{username}
    </select>

    <!-- 이메일로 사용자 조회 -->
    <select id="findByEmail" parameterType="string" resultMap="userEntityResultMap">
        SELECT id, username, email, is_active, status, order_count, created_at, updated_at, deleted_at
        FROM users
        WHERE email = #{email}
    </select>

    <!-- 사용자 등록 -->
    <insert id="insert" parameterType="com.core.domain.user.entity.UserEntity" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users (username, email, is_active, status, created_at)
        VALUES (#{username}, #{email}, #{isActive}, #{status}, NOW())
    </insert>

    <!-- 사용자 정보 수정 -->
    <update id="update" parameterType="com.core.domain.user.entity.UserEntity">
        UPDATE users
        SET username = #{username},
            email = #{email},
            is_active = #{isActive},
            status = #{status},
            updated_at = NOW()
        WHERE id = #{id}
    </update>

    <!-- 사용자 삭제 -->
    <delete id="deleteById" parameterType="long">
        DELETE FROM users
        WHERE id = #{id}
    </delete>

    <!-- 전체 사용자 수 조회 -->
    <select id="count" resultType="int">
        SELECT COUNT(*)
        FROM users
        WHERE deleted_at IS NULL
    </select>

    <!-- 사용자명 중복 체크 -->
    <select id="existsByUsername" parameterType="string" resultType="boolean">
        SELECT COUNT(*) > 0
        FROM users
        WHERE username = #{username}
        AND deleted_at IS NULL
    </select>

    <!-- 이메일 중복 체크 -->
    <select id="existsByEmail" parameterType="string" resultType="boolean">
        SELECT COUNT(*) > 0
        FROM users
        WHERE email = #{email}
        AND deleted_at IS NULL
    </select>

    <!-- ==================== 극한 동적 쿼리 예시 시작 ==================== -->

    <!-- SQL 재사용을 위한 fragment 정의 -->
    <sql id="baseColumns">
        u.id, u.username, u.email, u.is_active, u.status, u.order_count, u.created_at, u.updated_at, u.deleted_at
    </sql>

    <sql id="dynamicWhereConditions">
        <where>
            <!-- 단순 equals 조건 -->
            <if test="id != null">
                AND u.id = #{id}
            </if>
            <if test="username != null and username != ''">
                AND u.username = #{username}
            </if>
            <if test="email != null and email != ''">
                AND u.email = #{email}
            </if>

            <!-- LIKE 패턴 검색 -->
            <if test="usernamePattern != null and usernamePattern != ''">
                AND u.username LIKE CONCAT('%', #{usernamePattern}, '%')
            </if>
            <if test="emailPattern != null and emailPattern != ''">
                AND u.email LIKE CONCAT('%', #{emailPattern}, '%')
            </if>

            <!-- 범위 검색 (BETWEEN) -->
            <if test="minId != null and maxId != null">
                AND u.id BETWEEN #{minId} AND #{maxId}
            </if>
            <if test="minId != null and maxId == null">
                AND u.id &gt;= #{minId}
            </if>
            <if test="minId == null and maxId != null">
                AND u.id &lt;= #{maxId}
            </if>

            <!-- 날짜 범위 검색 -->
            <if test="startDate != null and endDate != null">
                AND u.created_at BETWEEN #{startDate} AND #{endDate}
            </if>
            <if test="startDate != null and endDate == null">
                AND u.created_at &gt;= #{startDate}
            </if>
            <if test="startDate == null and endDate != null">
                AND u.created_at &lt;= #{endDate}
            </if>

            <!-- IN 조건 (foreach 사용) -->
            <if test="ids != null and ids.size() > 0">
                AND u.id IN
                <foreach item="id" collection="ids" open="(" separator="," close=")">
                    #{id}
                </foreach>
            </if>

            <if test="usernames != null and usernames.size() > 0">
                AND u.username IN
                <foreach item="username" collection="usernames" open="(" separator="," close=")">
                    #{username}
                </foreach>
            </if>

            <!-- 이메일 도메인 검색 (여러 도메인) -->
            <if test="emailDomains != null and emailDomains.size() > 0">
                AND (
                <foreach item="domain" collection="emailDomains" separator=" OR ">
                    u.email LIKE CONCAT('%@', #{domain})
                </foreach>
                )
            </if>

            <!-- 복합 Boolean 조건 -->
            <if test="isActive != null">
                AND u.is_active = #{isActive}
            </if>
            <if test="includeDeleted == null or includeDeleted == false">
                AND u.deleted_at IS NULL
            </if>

            <!-- 상태 조건 (choose-when-otherwise) -->
            <choose>
                <when test="userStatus == 'active'">
                    AND u.status = 'ACTIVE' AND u.is_active = true
                </when>
                <when test="userStatus == 'inactive'">
                    AND u.status = 'INACTIVE' OR u.is_active = false
                </when>
                <when test="userStatus == 'suspended'">
                    AND u.status = 'SUSPENDED'
                </when>
                <otherwise>
                    <!-- 상태 조건 없음 -->
                </otherwise>
            </choose>

            <!-- OR 조건 그룹 (검색 키워드) -->
            <if test="searchKeywords != null and searchKeywords.size() > 0">
                AND (
                <foreach item="keyword" collection="searchKeywords" separator=" OR ">
                    (u.username LIKE CONCAT('%', #{keyword}, '%')
                    OR u.email LIKE CONCAT('%', #{keyword}, '%'))
                </foreach>
                )
            </if>

            <!-- EXISTS 서브쿼리 (주문이 있는 사용자만) -->
            <if test="hasOrders != null and hasOrders == true">
                AND EXISTS (
                    SELECT 1 FROM orders o
                    WHERE o.user_id = u.id
                )
            </if>

            <!-- 집계 함수를 사용한 HAVING 조건 (서브쿼리 형태) -->
            <if test="minOrderCount != null and minOrderCount > 0">
                AND u.id IN (
                    SELECT o.user_id
                    FROM orders o
                    GROUP BY o.user_id
                    HAVING COUNT(*) &gt;= #{minOrderCount}
                )
            </if>

            <!-- 우선순위 레벨 (CASE WHEN 활용) -->
            <if test="priorityLevel != null and priorityLevel != ''">
                AND (
                    CASE
                        WHEN u.order_count &gt;= 100 THEN 'VIP'
                        WHEN u.order_count &gt;= 50 THEN 'PREMIUM'
                        WHEN u.order_count &gt;= 10 THEN 'REGULAR'
                        ELSE 'NORMAL'
                    END
                ) = #{priorityLevel}
            </if>
        </where>
    </sql>

    <!-- 동적 ORDER BY -->
    <sql id="dynamicOrderBy">
        <choose>
            <when test="orderBy != null and orderBy == 'id'">
                ORDER BY u.id
            </when>
            <when test="orderBy != null and orderBy == 'username'">
                ORDER BY u.username
            </when>
            <when test="orderBy != null and orderBy == 'email'">
                ORDER BY u.email
            </when>
            <when test="orderBy != null and orderBy == 'created_at'">
                ORDER BY u.created_at
            </when>
            <otherwise>
                ORDER BY u.id
            </otherwise>
        </choose>
        <choose>
            <when test="sortDirection != null and sortDirection == 'ASC'">
                ASC
            </when>
            <when test="sortDirection != null and sortDirection == 'DESC'">
                DESC
            </when>
            <otherwise>
                DESC
            </otherwise>
        </choose>
    </sql>

    <!-- 동적 페이징 -->
    <sql id="dynamicPagination">
        <if test="limit != null and limit > 0">
            LIMIT #{limit}
        </if>
        <if test="offset != null and offset >= 0">
            OFFSET #{offset}
        </if>
    </sql>

    <!-- 극한 동적 쿼리 - 복잡한 검색 -->
    <select id="searchUsersWithDynamicQuery" parameterType="com.core.model.UserSearchCriteria" resultMap="userEntityResultMap">
        SELECT
            <include refid="baseColumns"/>
        FROM users u
        <include refid="dynamicWhereConditions"/>
        <include refid="dynamicOrderBy"/>
        <include refid="dynamicPagination"/>
    </select>

    <!-- 극한 동적 쿼리 - Count 쿼리 -->
    <select id="countUsersWithDynamicQuery" parameterType="com.core.model.UserSearchCriteria" resultType="int">
        SELECT COUNT(*)
        FROM users u
        <include refid="dynamicWhereConditions"/>
    </select>

    <!-- 극한 동적 쿼리 - 동적 UPDATE -->
    <update id="updateUserDynamically" parameterType="map">
        UPDATE users
        <set>
            <if test="username != null and username != ''">
                username = #{username},
            </if>
            <if test="email != null and email != ''">
                email = #{email},
            </if>
            <if test="isActive != null">
                is_active = #{isActive},
            </if>
            <if test="status != null and status != ''">
                status = #{status},
            </if>
            updated_at = NOW()
        </set>
        WHERE id = #{id}
    </update>

    <!-- 극한 동적 쿼리 - 대량 INSERT (foreach 활용) -->
    <insert id="batchInsertUsers" parameterType="list">
        INSERT INTO users (username, email, is_active, created_at)
        VALUES
        <foreach collection="list" item="user" separator=",">
            (#{user.username}, #{user.email}, #{user.isActive}, NOW())
        </foreach>
    </insert>

    <!-- 극한 동적 쿼리 - 동적 DELETE (여러 조건) -->
    <delete id="deleteUsersDynamically" parameterType="com.core.model.UserSearchCriteria">
        DELETE FROM users
        <where>
            <if test="ids != null and ids.size() > 0">
                AND id IN
                <foreach item="id" collection="ids" open="(" separator="," close=")">
                    #{id}
                </foreach>
            </if>
            <if test="startDate != null and endDate != null">
                AND created_at BETWEEN #{startDate} AND #{endDate}
            </if>
            <if test="userStatus != null and userStatus != ''">
                AND status = #{userStatus}
            </if>
        </where>
    </delete>

    <!-- 극한 동적 쿼리 - 복잡한 JOIN과 서브쿼리 -->
    <select id="searchUsersWithOrdersAndStats" parameterType="com.core.model.UserSearchCriteria" resultType="map">
        SELECT
            u.id,
            u.username,
            u.email,
            u.created_at,
            COALESCE(o.order_count, 0) AS order_count,
            COALESCE(o.total_amount, 0) AS total_amount,
            CASE
                WHEN COALESCE(o.order_count, 0) &gt;= 100 THEN 'VIP'
                WHEN COALESCE(o.order_count, 0) &gt;= 50 THEN 'PREMIUM'
                WHEN COALESCE(o.order_count, 0) &gt;= 10 THEN 'REGULAR'
                ELSE 'NORMAL'
            END AS customer_tier
        FROM users u
        <if test="hasOrders == null or hasOrders == true">
            LEFT JOIN (
                SELECT
                    user_id,
                    COUNT(*) AS order_count,
                    SUM(amount) AS total_amount
                FROM orders
                <where>
                    <if test="startDate != null and endDate != null">
                        AND created_at BETWEEN #{startDate} AND #{endDate}
                    </if>
                </where>
                GROUP BY user_id
            ) o ON u.id = o.user_id
        </if>
        <where>
            <if test="id != null">
                AND u.id = #{id}
            </if>
            <if test="usernamePattern != null and usernamePattern != ''">
                AND u.username LIKE CONCAT('%', #{usernamePattern}, '%')
            </if>
            <if test="minOrderCount != null and minOrderCount > 0">
                AND COALESCE(o.order_count, 0) &gt;= #{minOrderCount}
            </if>
            <if test="priorityLevel != null and priorityLevel != ''">
                AND (
                    CASE
                        WHEN COALESCE(o.order_count, 0) &gt;= 100 THEN 'VIP'
                        WHEN COALESCE(o.order_count, 0) &gt;= 50 THEN 'PREMIUM'
                        WHEN COALESCE(o.order_count, 0) &gt;= 10 THEN 'REGULAR'
                        ELSE 'NORMAL'
                    END
                ) = #{priorityLevel}
            </if>
        </where>
        <include refid="dynamicOrderBy"/>
        <include refid="dynamicPagination"/>
    </select>

    <!-- ==================== 극한 동적 쿼리 예시 종료 ==================== -->

</mapper>
